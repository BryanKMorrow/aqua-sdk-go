package main

import (
	"log"
	"os"
	"sort"
	"time"

	"github.com/BryanKMorrow/aqua-sdk-go/client"
	"github.com/BryanKMorrow/aqua-sdk-go/types/images"
)

type Vuln struct {
	Name          string               `json:"name"`
	Vulnerability images.Vulnerability `json:"vulnerability"`
	Images        []ImageFinding       `json:"images"`
}

// ImageFinding stores the findings report images: [] data
type ImageFinding struct {
	Registry              string               `json:"registry"`
	Name                  string               `json:"name"`
	VulnsFound            int                  `json:"vulns_found"`
	CritVulns             int                  `json:"crit_vulns"`
	HighVulns             int                  `json:"high_vulns"`
	MedVulns              int                  `json:"med_vulns"`
	LowVulns              int                  `json:"low_vulns"`
	NegVulns              int                  `json:"neg_vulns"`
	FixableVulns          int                  `json:"fixable_vulns"`
	RegistryType          string               `json:"registry_type"`
	Repository            string               `json:"repository"`
	Tag                   string               `json:"tag"`
	Created               time.Time            `json:"created"`
	Author                string               `json:"author"`
	Digest                string               `json:"digest"`
	Size                  int                  `json:"size"`
	Os                    string               `json:"os"`
	OsVersion             string               `json:"os_version"`
	ScanStatus            string               `json:"scan_status"`
	ScanDate              time.Time            `json:"scan_date"`
	ScanError             string               `json:"scan_error"`
	SensitiveData         int                  `json:"sensitive_data"`
	Malware               int                  `json:"malware"`
	Disallowed            bool                 `json:"disallowed"`
	Whitelisted           bool                 `json:"whitelisted"`
	Blacklisted           bool                 `json:"blacklisted"`
	PermissionAuthor      string               `json:"permission_author"`
	PartialResults        bool                 `json:"partial_results"`
	NewerImageExists      bool                 `json:"newer_image_exists"`
	PendingDisallowed     bool                 `json:"pending_disallowed"`
	MicroenforcerDetected bool                 `json:"microenforcer_detected"`
	Running               bool                 `json:"is_running"`
	ScanHistory           []ScanHistoryFinding `json:"scan_history,omitempty"`
	Vulnerabilities       []string             `json:"vulnerabilities,omitempty"`
}

type ScanHistoryFinding struct {
	Registry             string    `json:"registry"`
	Repository           string    `json:"repository"`
	Name                 string    `json:"name"`
	Tag                  string    `json:"tag"`
	Date                 time.Time `json:"date"`
	Error                string    `json:"error"`
	Digest               string    `json:"digest"`
	DockerID             string    `json:"docker_id"`
	ImagePulled          bool      `json:"image_pulled"`
	ImageCreationDate    time.Time `json:"image_creation_date"`
	SensitiveDataScanned bool      `json:"sensitive_data_scanned"`
	ExecutablesScanned   bool      `json:"executables_scanned"`
	MalwareScanned       bool      `json:"malware_scanned"`
	CritVulns            int       `json:"crit_vulns"`
	HighVulns            int       `json:"high_vulns"`
	MedVulns             int       `json:"med_vulns"`
	LowVulns             int       `json:"low_vulns"`
	NegVulns             int       `json:"neg_vulns"`
	SensitiveData        int       `json:"sensitive_data"`
	Malware              int       `json:"malware"`
	Disallowed           bool      `json:"disallowed"`
	PartialResults       bool      `json:"partial_results"`
}

func main() {
	// Get the Aqua CSP connection parameters from Environment Variables
	url := os.Getenv("AQUA_URL")
	user := os.Getenv("AQUA_USER")
	password := os.Getenv("AQUA_PASSWORD")

	// Create the client and get the JWT token for API call authorization
	cli := client.NewClient(url, user, password)
	connected := cli.GetAuthToken()
	if !connected {
		log.Fatalln("Failed to retrieve JWT Authorization Token")
	} else {
		// Get All Vulnerabilities
		var vl []images.Vulnerability
		detail, remaining, next, total := cli.GetRiskVulnerabilities(1, 1000, nil)
		log.Printf("Vulnerabilities Remaining: %d  Next: %d  Total: %d", remaining, next, total)
		vl = append(vl, detail.Result...)
		for remaining > 0 {
			detail, remaining, next, total = cli.GetRiskVulnerabilities(next, 1000, nil)
			log.Printf("Vulnerabilities Remaining: %d  Next: %d  Total: %d", remaining, next, total)
			vl = append(vl, detail.Result...)
		}
		// Get All Images
		var il []images.Image
		images, remaining, next, total := cli.GetAllImages(0, 1000, nil, nil)
		log.Printf("Images Remaining: %d  Next: %d  Total: %d", remaining, next, total)
		il = append(il, images.Result...)
		for remaining > 0 {
			images, remaining, next, total = cli.GetAllImages(0, 1000, nil, nil)
			log.Printf("Images Remaining: %d  Next: %d  Total: %d", remaining, next, total)
			il = append(il, images.Result...)
		}
		// Loop through each image and get its vulnerabilities
		ifl := ConvertImageToFinding(cli, il)

		// Loop through each vulnerability and map images to Vuln
		vulns := []Vuln{}
		for _, v := range vl {
			var vuln Vuln
			i, found := Find(vulns, v.Name)
			if !found {
				vuln.Name = v.Name
				vuln.Vulnerability = v
				ok, img := vuln.MapVulnerabilityToImage(ifl)
				if ok {
					vuln.Images = append(vuln.Images, img)
					vulns = append(vulns, vuln)
				}
			} else {
				ok, img := vulns[i].MapVulnerabilityToImage(ifl)
				if ok {
					vulns[i].Images = append(vulns[i].Images, img)
				}
			}
		}
		sort.Slice(vulns, func(i, j int) bool {
			if len(vulns[i].Images) > len(vulns[j].Images) {
				return true
			}
			if len(vulns[i].Images) < len(vulns[j].Images) {
				return false
			}
			return vulns[i].Name < vulns[j].Name
		})
		log.Println("Top 25 Vulnerabilities by Image Count")
		for _, q := range vulns[:25] {
			log.Printf("Vulnerability: %s  Image Count: %d", q.Name, len(q.Images))
		}
	}
}

func (v *Vuln) MapVulnerabilityToImage(il []ImageFinding) (bool, ImageFinding) {
	for _, image := range il {
		for _, vuln := range image.Vulnerabilities {
			if v.Name == vuln {
				_, found := FindImageInVuln(v.Images, image.Name)
				if !found {
					return true, image
				}
			}
		}
	}
	return false, ImageFinding{}
}

func Find(vulns []Vuln, name string) (int, bool) {
	log.Printf("Name: %s  Vulns: %d", name, len(vulns))
	for i, vuln := range vulns {
		if vuln.Name == name {
			return i, true
		}
	}
	return -1, false
}

func FindImageInVuln(il []ImageFinding, name string) (int, bool) {
	for index, i := range il {
		if i.Name == name {
			return index, true
		}
	}
	return -1, false
}

func ConvertImageToFinding(cli *client.Client, il []images.Image) []ImageFinding {
	var ifl []ImageFinding
	for _, i := range il {
		var vil []images.Vulnerability
		var vfi []string
		vuln, remaining, next, _ := cli.GetVulnerabilities(i.Registry, i.Repository, i.Tag, 0, 1000, nil, nil)
		vil = append(vil, vuln.Result...)
		for remaining > 0 {
			vuln, remaining, _, _ = cli.GetVulnerabilities(i.Registry, i.Repository, i.Tag, next, 1000, nil, nil)
			vil = append(vil, vuln.Result...)
		}
		for _, v := range vil {
			vfi = append(vfi, v.Name)
		}
		ivf := ImageFinding{
			Registry:        i.Registry,
			Name:            i.Name,
			VulnsFound:      i.VulnsFound,
			CritVulns:       i.CritVulns,
			HighVulns:       i.HighVulns,
			MedVulns:        i.MedVulns,
			LowVulns:        i.LowVulns,
			NegVulns:        i.NegVulns,
			RegistryType:    i.RegistryType,
			Repository:      i.Repository,
			Tag:             i.Tag,
			Created:         i.Created,
			ScanDate:        i.ScanDate,
			SensitiveData:   i.SensitiveData,
			Malware:         i.Malware,
			Disallowed:      i.Disallowed,
			Vulnerabilities: vfi,
		}
		ifl = append(ifl, ivf)
	}
	return ifl
}
