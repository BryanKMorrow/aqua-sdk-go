package main

import (
	"github.com/BryanKMorrow/aqua-sdk-go/client"
	"github.com/BryanKMorrow/aqua-sdk-go/types/images"
	"log"
	"os"
	"sort"
)

type Vuln struct {
	Name          string               `json:"name"`
	Vulnerability images.Vulnerability `json:"vulnerability"`
	Images        []images.Image       `json:"images"`
}

func main() {
	// Get the Aqua CSP connection parameters from Environment Variables
	url := os.Getenv("AQUA_URL")
	user := os.Getenv("AQUA_USER")
	password := os.Getenv("AQUA_PASSWORD")

	// Create the client and get the JWT token for API call authorization
	cli := client.NewClient(url, user, password)
	connected := cli.GetAuthToken()
	if !connected {
		log.Fatalln("Failed to retrieve JWT Authorization Token")
	} else {
		// Get All Vulnerabilities
		var vl []images.Vulnerability
		detail, remaining, next, total := cli.GetRiskVulnerabilities(1, 1000, nil)
		log.Printf("Vulnerabilities Remaining: %d  Next: %d  Total: %d", remaining, next, total)
		vl = append(vl, detail.Result...)
		for remaining > 0 {
			detail, remaining, next, total = cli.GetRiskVulnerabilities(next, 1000, nil)
			log.Printf("Vulnerabilities Remaining: %d  Next: %d  Total: %d", remaining, next, total)
			vl = append(vl, detail.Result...)
		}
		// Get All Images
		var il []images.Image
		images, remaining, next, total := cli.GetAllImages(0, 1000, nil, nil)
		log.Printf("Images Remaining: %d  Next: %d  Total: %d", remaining, next, total)
		il = append(il, images.Result...)
		for remaining > 0 {
			images, remaining, next, total = cli.GetAllImages(0, 1000, nil, nil)
			log.Printf("Images Remaining: %d  Next: %d  Total: %d", remaining, next, total)
			il = append(il, images.Result...)
		}
		// Loop through each vulnerability and map images to Vuln
		vulns := []Vuln{}
		for _, v := range vl {
			var vuln Vuln
			i, found := Find(vulns, v.Name)
			if !found {
				vuln.Name = v.Name
				vuln.Vulnerability = v
				ok, img := vuln.MapVulnerabilityToImage(il)
				if ok {
					vuln.Images = append(vuln.Images, img)
					vulns = append(vulns, vuln)
				}
			} else {
				ok, img := vulns[i].MapVulnerabilityToImage(il)
				if ok {
					vulns[i].Images = append(vulns[i].Images, img)
				}
			}
		}
		sort.Slice(vulns, func(i, j int) bool {
			if len(vulns[i].Images) > len(vulns[j].Images) {
				return true
			}
			if len(vulns[i].Images) < len(vulns[j].Images) {
				return false
			}
			return vulns[i].Name < vulns[j].Name
		})
		log.Println("Top 25 Vulnerabilities by Image Count")
		for _, q := range vulns[:25] {
			log.Printf("Vulnerability: %s  Image Count: %d", q.Name, len(q.Images))
		}
	}
}

func (v *Vuln) MapVulnerabilityToImage(il []images.Image) (bool, images.Image) {
	for _, image := range il {
		if (v.Vulnerability.ImageName == image.Name) && (v.Vulnerability.Registry == image.Registry) {
			return true, image
		}
	}
	return false, images.Image{}
}

func Find(vulns []Vuln, name string) (int, bool) {
	log.Printf("Name: %s  Vulns: %d", name, len(vulns))
	for i, vuln := range vulns {
		if vuln.Name == name {
			return i, true
		}
	}
	return -1, false
}
